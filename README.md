# WASM demo: Javascript in Python 

Trying to compile a javascript obfuscator to a web assembly module as a component using a Wasm Interface Type (WIT),
then run from Python.

## How to Run

Install esbuild, componentize-js and jco

```
npm install
```

Install wasmtime

```
pip install wasmtime
```

Build

```
make build
```

Run

```
make run
```

It works with small inputs but crashes with larger inputs.

```
▶ make run

Running tiny sample: 2KB
Node internal call:   0.071s
Python node syscall:  0.228s
Python wasm module:   0.216s
Python wasm instance: 0.220s

Running small sample: 17KB
Node internal call:   0.272s
Python node syscall:  0.398s
Python wasm module:   1.372s
Python wasm instance: 1.377s

Running medium sample: 55KB
Node internal call:   0.526s
Python node syscall:  0.642s
Python wasm module:   4.956s
Python wasm instance: 4.912s

Running large sample: 400KB
Node internal call:   1.313s
Python node syscall:  1.432s
Traceback (most recent call last):
  File "/mnt/f/web/junk/wasm-py/obfuscate-uni.py", line 21, in <module>
    main()
  File "/mnt/f/web/junk/wasm-py/obfuscate-uni.py", line 14, in main
    out = demo.obfuscate(store, src)
  File "/mnt/f/web/junk/wasm-py/obfuscate/__init__.py", line 26, in obfuscate
    ret = self.lift_callee0(caller, ptr, len0)
  File "/home/kev/.local/lib/python3.10/site-packages/wasmtime/_func.py", line 91, in __call__
    with enter_wasm(store) as trap:
  File "/usr/lib/python3.10/contextlib.py", line 142, in __exit__
    next(self.gen)
  File "/home/kev/.local/lib/python3.10/site-packages/wasmtime/_func.py", line 264, in enter_wasm
    raise trap_obj
wasmtime._trap.Trap: error while executing at wasm backtrace:
    0: 0x57fbec - <unknown>!<wasm function 6688>
    1: 0x582661 - <unknown>!<wasm function 7282>
    2: 0x33719c - <unknown>!<wasm function 603>
    3: 0x57f91f - <unknown>!obfuscate

Caused by:
    wasm trap: wasm `unreachable` instruction executed
make: *** [Makefile:36: run-large] Error 1
```

Apparently the module instance somehow becomes corrupt when the input is greater than 64KB. There is no information on
the internet to explain this behavior but we can extrapolate from the small and medium sample size that performance is
likely to scale poorly with larger samples.

## Modifying for production

The code generated by wasmtime.bindgen creates a single reusable instance.
That won't work for us because if you try to run it a bunch of times, it will crash.

```py
for x in range(100):
    out = demo.obfuscate(store, src)
```

Crashes with

```
Traceback (most recent call last):
  File "/mnt/f/web/junk/wasm-py/obfuscate.py", line 25, in <module>
    main()
  File "/mnt/f/web/junk/wasm-py/obfuscate.py", line 14, in main
    out = demo.obfuscate(store, src)
  File "/mnt/f/web/junk/wasm-py/obfuscate/__init__.py", line 28, in obfuscate
    ret = self.lift_callee0(caller, ptr, len0)
  File "/home/kev/.local/lib/python3.10/site-packages/wasmtime/_func.py", line 91, in __call__
    with enter_wasm(store) as trap:
  File "/usr/lib/python3.10/contextlib.py", line 142, in __exit__
    next(self.gen)
  File "/home/kev/.local/lib/python3.10/site-packages/wasmtime/_func.py", line 264, in enter_wasm
    raise trap_obj
wasmtime._trap.Trap: error while executing at wasm backtrace:
    0: 0x2a83e8 - <unknown>!<wasm function 329>
    1: 0x4ffad7 - <unknown>!<wasm function 3301>
    2: 0x3da468 - <unknown>!<wasm function 1137>
    3: 0x33703e - <unknown>!<wasm function 603>
    4: 0x57f91f - <unknown>!obfuscate

Caused by:
    0: memory fault at wasm address 0x4b4b4b4b in linear memory of size 0x4310000
    1: wasm trap: out of bounds memory access
make: *** [Makefile:7: run] Error 1
```

### Alteration

Instead, we need to create a new instance of the module on invocation (see `obfuscator.py`).

```py
class Obfuscator:

    def __init__(self) -> None:
        path = pathlib.Path(__file__).parent / ('obfuscate/root.core0.wasm')
        self._store = wasmtime.Store()
        self._module = wasmtime.Module.from_file(self._store.engine, path)
    def obfuscate(self, src: str) -> str:
        instance = wasmtime.Instance(self._store, self._module, []).exports(self._store)
        memory = instance["memory"]
        realloc = instance["cabi_realloc"]
        lift_callee = instance["obfuscate"]
        ptr, len0 = _encode_utf8(src, realloc, memory, self._store)
        ret = lift_callee(self._store, ptr, len0)
        load = _load(ctypes.c_int32, memory, self._store, ret, 0)
        load1 = _load(ctypes.c_int32, memory, self._store, ret, 4)
        ptr2 = load
        len3 = load1
        list = _decode_utf8(memory, self._store, ptr2, len3)
        del instance
        return list

```

This turns out to be just as fast as using a single instance because the module is still only compiled once.

### Further investigation

- [ ] Can we make this work for javascript larger than 64KB?
- [ ] Does this work for js using es6 features?

## Javy

So we tried javy and performance is not good. 10x slower than node.

```
▶ time cat input/chart.js | python3.10 obfuscate.javy.py > output/chart.js

real    0m11.172s
user    0m11.942s
sys     0m0.121s

▶ time python3.10 obfuscate-node.py chart.js
Node internal call:   1.314s
Python node syscall:  1.437s

real    0m1.477s
user    0m1.965s
sys     0m0.132s
```

This might not even have anything to do with the webassembly and could just be a python problem.

https://github.com/bytecodealliance/wasmtime-py/issues/96

> Not much attention has been paid to performance in the bindings in this repository, so this isn't altogether
unsurprising. I have never personally written high-performance Python and consequently probably made a ton of mistakes
when writing these bindings.
